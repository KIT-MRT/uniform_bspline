#!/usr/bin/env wolframscript

If [Length[$ScriptCommandLine] != 5,
    Print["Usage: generate_bspline_basis_cpp_files <output file path> <min spline order> <max spline order> <max spline smoothness derivative>"];
    Exit[1];
];

Get["exporter.m"];
SeedRandom[1];

scriptName = Last[FileNameSplit[$ScriptCommandLine[[1]]]];
rootDir = ExpandFileName[$ScriptCommandLine[[2]]];
minDegree = ToExpression[$ScriptCommandLine[[3]]];
maxDegree = ToExpression[$ScriptCommandLine[[4]]];
maxDerivative = ToExpression[$ScriptCommandLine[[5]]];

Print["Output directory: " <> rootDir]
If[!DirectoryQ[rootDir], CreateDirectory[rootDir]];

x[degree_, t_] := Flatten[{1, Table[t^i, {i, 1, degree}]}];

getMatrix[degree_] := Module[{order, numPoints, knotFunc, knots, basis, res, m, c, t},
    order = degree + 1;
    numPoints = order;
    knotFunc[x_] := Evaluate[(m * x + c)/.Solve[{m * order + c == 0, m * (numPoints + 1) + c == 1}, {m, c}][[1]]];
    knots = Table[knotFunc[i], {i, 1, numPoints + order}];

    basis = Table[PiecewiseExpand[BSplineBasis[{degree, knots}, i, t]], {i, 0, numPoints - 1}];
    res = (Simplify[#, t > 0 && t < 1])&/@basis;
    CoefficientList[res, t]
]

getSmoothnessMatrix[degree_, derivative_] := Module[{dx, m, sm},
    dx = D[x[degree, t], {t, derivative}];
    m = getMatrix[degree];

    sm = m.Integrate[Transpose[{dx}].{dx}, {t, 0, 1}].Transpose[m];
    sm
]

getSmoothnessMatrixRoot[degree_, derivative_] := Module[{dx, m, sm},
    dx = D[x[degree, t], {t, derivative}];
    m = getMatrix[degree];

    sm = N[MatrixPower[m.Integrate[Transpose[{dx}].{dx}, {t, 0, 1}].Transpose[m], 1/2], 50];
    sm
]

evalBSpline[m_, points_, val_] := Module[{degree, scale, baseX, xv, xi, v},
    degree = Length[m] - 1;
    scale = Length[points] - degree;
    baseX = val * scale;

    xi = Min[{IntegerPart[baseX] + 1}, Length[points] - degree];
    xv = baseX - xi + 1;

    If[Length[Dimensions[points]] == 1,
        points[[xi;;xi + degree]].m.x[degree, xv],
        Transpose[points[[xi;;xi + degree]]].m.x[degree, xv]
    ]
]

evalBSplineSmoothness[degree_, derivative_, points_] := Module[{scale, sm},
    sm = getSmoothnessMatrixRoot[degree, derivative];
    scale = Length[points] - degree;
    Sum[Norm[sm.points[[i;;i + degree]] * scale^(derivative - 1/2)]^2, {i, 1, scale}]
]

(* Test spline evaluation *)
Block[{},
    points = RandomReal[{-1, 1}, 20];
    degree = 4;
    refBSpline = BSplineFunction[points, SplineDegree -> degree, SplineKnots -> "Unclamped"];
    pos = 1/10;
    gtVal = refBSpline[pos];
    basisVal = evalBSpline[getMatrix[degree], points, pos];
    If[Norm[gtVal - basisVal] > 10^-14,
        Print["B-spline evaluation test failed.\nBuilt-in B-spline value: " <> ToString[gtVal, CForm] <> "\n" <>
              "B-spline matrix computation value: " <> ToString[basisVal, CForm]];
    ];
];

(* Test smoothness evaluation *)
Block[{},
    derivative = 1;
    gtVal = NIntegrate[Abs[D[refBSpline[x], {x, derivative}]]^2, {x, 0, 1}, MaxRecursion -> 100];
    basisVal = evalBSplineSmoothness[degree, derivative, points];
    If[Norm[gtVal - basisVal] > 10^-12,
        Print["Smoothness matrix evaluation test failed.\nNumeric integration value: " <> ToString[gtVal, CForm] <> "\n" <>
              "Smoothness matrix computation value: " <> ToString[basisVal, CForm]];
    ];
];

basisWriter[xMin_, xMax_] := Module[{file, data, m},
    (* Writer header *)
    file = {
        "// Do not edit this file. This file was generated by a script:", 
        "// '" <> scriptName <> " " <> ToString[minDegree] <> " " <> ToString[maxDegree] <> " " <> ToString[maxDerivative]<> "'",
        "#pragma once",
        "#include <Eigen/Core>",
        "",
        "namespace ubs {",
        "/** @brief Internal namespace */",
        "namespace internal {",
        "template <int Order_>",
        "struct UniformBSplineBasis;",
        ""};

    Do[
        Print["Generate spline basis for order " <> ToString[i]];
        AppendTo[file, "template <> "];
        AppendTo[file, "struct UniformBSplineBasis<" <> ToString[i + 1] <> "> {"];
        AppendTo[file, "    static Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> matrix() {"];
        AppendTo[file, "        Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> m{};"];

        m = getMatrix[i];
        m = Flatten[Transpose[Reverse[Transpose[m]]]];
        data = matToString[m, ", "];

        AppendTo[file, "        m << " <> data <> ";"];
        AppendTo[file, "        return m;"];
        AppendTo[file, "    }"];
        AppendTo[file, "};"];
        AppendTo[file, ""];
    ,{i, xMin, xMax}];
    AppendTo[file, "} // namespace internal"];
    AppendTo[file, "} // namespace ubs"];
    file
];

smoothnessWriter[xMin_, xMax_, maxDerivative_] := Module[{file, data, m},
    (* Writer header *)
    file = {
        "// Do not edit this file. This file was generated by a script:", 
        "// '" <> scriptName <> " " <> ToString[minDegree] <> " " <> ToString[maxDegree] <> " " <> ToString[maxDerivative]<> "'",
        "#pragma once",
        "#include <Eigen/Core>",
        "",
        "namespace ubs {",
        "/** @brief Internal namespace */",
        "namespace internal {",
        "template <int Order_, int Derivative_>",
        "struct UniformBSplineSmoothnessBasis;",
        ""};

    Do[
        If[d > i, Continue[]];

        Print["Generate spline smoothness basis for degree " <> ToString[i] <> " and derivative " <> ToString[d]];
        AppendTo[file, "template <> "];
        AppendTo[file, "struct UniformBSplineSmoothnessBasis<" <> ToString[i + 1] <> ", " <> ToString[d] <> "> {"];
        AppendTo[file, "    static Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> matrix() {"];
        AppendTo[file, "        Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> m{};"];

        m = Flatten[getSmoothnessMatrix[i, d]];
        data = matToString[m, ", "];

        AppendTo[file, "        m << " <> data <> ";"];
        AppendTo[file, "        return m;"];
        AppendTo[file, "    }"];

        AppendTo[file, "    static Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> matrixRoot() {"];
        AppendTo[file, "        Eigen::Matrix<double, " <> ToString[i + 1] <> ", " <> ToString[i + 1] <> "> m{};"];

        m = Flatten[getSmoothnessMatrixRoot[i, d]];
        data = matToString[m, ", "];

        AppendTo[file, "        m << " <> data <> ";"];
        AppendTo[file, "        return m;"];
        AppendTo[file, "    }"];

        AppendTo[file, "};"];
        AppendTo[file, ""];
    ,{i, xMin, xMax}, {d, 0, maxDerivative}];

    AppendTo[file, "} // namespace internal"];
    AppendTo[file, "} // namespace ubs"];
    file
];

path = rootDir <> "/base_matrix.hpp";
Export[path, basisWriter[minDegree, maxDegree], "Table"];
Run["clang-format -i \"" <> path <> "\""];

path = rootDir <> "/smoothness_matrix.hpp";
Export[path, smoothnessWriter[minDegree, maxDegree, maxDerivative], "Table"];
Run["clang-format -i \"" <> path <> "\""];
